Index: scripts/world/npcs_special.cpp
===================================================================
--- scripts/world/npcs_special.cpp	(revision 1815)
+++ scripts/world/npcs_special.cpp	(working copy)
@@ -1718,6 +1718,176 @@
     return true;
 }
 
+/*######
+## npc_mirror_image
+######*/
+
+enum MirrorImageSpells
+{
+    SPELL_CLONE_CASTER    = 45204,
+    SPELL_CLONE_CASTER_1  = 69837,
+    SPELL_RESET_TARGETING = 62196,
+//    SPELL_CLONE_THREAT    = 58838,
+    SPELL_FIREBLAST       = 59637,
+    SPELL_FROSTBOLT       = 59638,
+    SPELL_ICEBLOCK        = 45438,
+    SPELL_ICERING         = 42917,
+
+    SPELL_FROSTSHIELD     = 43008,
+    SPELL_FIRESHIELD      = 43046,
+};
+
+struct MANGOS_DLL_DECL npc_mirror_imageAI : public ScriptedAI
+{
+    npc_mirror_imageAI(Creature* pCreature) : ScriptedAI(pCreature) {Reset();}
+
+    uint32 m_uiFrostboltTimer;
+    uint32 m_uiFrostringTimer;
+    uint32 m_uiFireblastTimer;
+    bool inCombat;
+    Unit *owner;
+    float angle;
+    bool blocked;
+    bool movement;
+
+    void Reset() 
+    {
+     m_creature->SetUInt32Value(UNIT_FIELD_FLAGS, UNIT_FLAG_PVP_ATTACKABLE);
+
+     m_uiFrostboltTimer = 0;//urand(4000,8000); //not wait before cast of firstcasting spell
+     m_uiFrostringTimer = urand(4000,8000);
+     m_uiFireblastTimer = urand(4000,8000);
+     inCombat = false;
+     blocked = false;
+     movement = false;
+    }
+
+    void AttackStart(Unit* pWho)
+    {
+      if (!(owner = m_creature->GetOwner())) return;
+      if (!pWho) return;
+
+      if (m_creature->Attack(pWho, false))
+        {
+	    owner->CastSpell(pWho, SPELL_RESET_TARGETING, true);
+            m_creature->clearUnitState(UNIT_STAT_FOLLOW);
+            m_creature->SetInCombatWith(pWho);
+            pWho->SetInCombatWith(m_creature);
+            m_creature->AddThreat(pWho, 100.0f);
+            DoStartMovement(pWho, 30.0f);
+            SetCombatMovement(true);
+            inCombat = true;
+        }
+    }
+
+    void EnterEvadeMode()
+    {
+     if (m_creature->IsInEvadeMode() || !m_creature->isAlive())
+          return;
+
+        inCombat = false;
+
+        m_creature->AttackStop();
+        m_creature->CombatStop(true);
+    }
+
+    void ReCast(uint32 diff)
+    {
+	if (owner->HasAura(diff) && !m_creature->HasAura(diff))
+	switch(diff)	
+	{	
+			//m_creature->CastSpell(m_creature, diff, true, NULL, NULL, owner->GetGUID());
+		case SPELL_FROSTSHIELD:
+		case SPELL_FIRESHIELD:				
+        		m_creature->CastSpell(m_creature, diff, false);			
+	}
+    }
+
+    void UpdateAI(const uint32 diff)
+    {
+	if (!(owner = m_creature->GetOwner())) return;
+
+	Unit* creature_victim = m_creature->getVictim();
+	Unit* owner_victim = owner->getVictim();
+
+        if (!owner->isAlive()) m_creature->ForcedDespawn();
+
+	ReCast(SPELL_FROSTSHIELD);
+	ReCast(SPELL_FIRESHIELD);
+
+	m_creature->SetPvP(owner->IsPvP());
+	m_creature->SetFFAPvP(owner->IsFFAPvP());	
+
+	//choosing victim
+	if (owner_victim)	
+	{
+		//attack owner victim
+        	if (!creature_victim || creature_victim != owner_victim)
+		{
+                	AttackStart(owner_victim);
+			creature_victim = owner_victim;
+		}
+	}
+
+	if (!inCombat)
+	{
+		//moving out of combat
+		if (!m_creature->hasUnitState(UNIT_STAT_FOLLOW))
+		{
+			angle = m_creature->GetAngle(owner);
+			m_creature->GetMotionMaster()->Clear(false);
+			m_creature->GetMotionMaster()->MoveFollow(owner, PET_FOLLOW_DIST , angle);
+		}
+		return;
+	}
+//	else if (!creature_victim) EnterEvadeMode();
+
+      //actions in combat
+      if(!blocked)
+      {
+	if (m_creature->IsWithinDistInMap(creature_victim,30.0f))
+	   {
+	       movement = false;
+	       if (m_uiFrostringTimer <= diff && m_creature->IsWithinDistInMap(creature_victim,10.0f))
+	       {
+	           DoCastSpellIfCan(creature_victim,SPELL_ICERING);
+	           m_uiFrostringTimer = urand(2000,5000);
+	       } else m_uiFrostringTimer -= diff;
+
+               if (m_uiFrostboltTimer <= diff)
+	       {
+	           DoCastSpellIfCan(creature_victim,SPELL_FROSTBOLT);
+	           m_uiFrostboltTimer = urand(4000,6000);
+	       } else m_uiFrostboltTimer -= diff;
+
+	       if (m_uiFireblastTimer <= diff)
+	       {
+	           DoCastSpellIfCan(creature_victim,SPELL_FIREBLAST);
+	           m_uiFireblastTimer = urand(4000,8000);
+	       } else m_uiFireblastTimer -= diff;
+
+	       if (m_creature->GetHealthPercent() < 10.0f)
+	       {
+	           m_creature->CastSpell(m_creature, SPELL_ICEBLOCK, false);
+	           blocked = true;
+	       }
+	   } 
+	   else	if (!movement)
+	 	 	{
+		             DoStartMovement(creature_victim, 10.0f);
+		             movement = true;
+		        }    	
+	      
+	}   //DoMeleeAttackIfReady(); 		 
+    }
+};
+
+CreatureAI* GetAI_npc_mirror_image(Creature* pCreature)
+{
+    return new npc_mirror_imageAI(pCreature);
+};
+
+
 bool GossipSelect_npc_locksmith(Player* pPlayer, Creature* pCreature, uint32 uiSender, uint32 uiAction)
 {
     switch(uiAction)
@@ -1839,4 +2009,9 @@
     newscript->pGossipHello =  &GossipHello_npc_locksmith;
     newscript->pGossipSelect = &GossipSelect_npc_locksmith;
     newscript->RegisterSelf();
+
+    newscript = new Script;
+    newscript->Name = "npc_mirror_image";
+    newscript->GetAI = &GetAI_npc_mirror_image;
+    newscript->RegisterSelf();
 }
